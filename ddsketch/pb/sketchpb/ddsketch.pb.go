// Unless explicitly stated otherwise all files in this repository are licensed under the Apache License 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2021 Datadog, Inc.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ddsketch.proto

package sketchpb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type IndexMapping_Interpolation int32

const (
	IndexMapping_NONE      IndexMapping_Interpolation = 0
	IndexMapping_LINEAR    IndexMapping_Interpolation = 1
	IndexMapping_QUADRATIC IndexMapping_Interpolation = 2
	IndexMapping_CUBIC     IndexMapping_Interpolation = 3
)

var IndexMapping_Interpolation_name = map[int32]string{
	0: "NONE",
	1: "LINEAR",
	2: "QUADRATIC",
	3: "CUBIC",
}

var IndexMapping_Interpolation_value = map[string]int32{
	"NONE":      0,
	"LINEAR":    1,
	"QUADRATIC": 2,
	"CUBIC":     3,
}

func (x IndexMapping_Interpolation) String() string {
	return proto.EnumName(IndexMapping_Interpolation_name, int32(x))
}

func (IndexMapping_Interpolation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{1, 0}
}

// A DDSketch is essentially a histogram that partitions the range of positive values into an infinite number of
// indexed bins whose size grows exponentially. It keeps track of the number of values (or possibly floating-point
// weights) added to each bin. Negative values are partitioned like positive values, symmetrically to zero.
// The value zero as well as its close neighborhood that would be mapped to extreme bin indexes is mapped to a specific
// counter.
type DDSketch struct {
	// The mapping between positive values and the bin indexes they belong to.
	Mapping *IndexMapping `protobuf:"bytes,1,opt,name=mapping,proto3" json:"mapping,omitempty"`
	// The store for keeping track of positive values.
	PositiveValues *Store `protobuf:"bytes,2,opt,name=positiveValues,proto3" json:"positiveValues,omitempty"`
	// The store for keeping track of negative values. A negative value v is mapped using its positive opposite -v.
	NegativeValues *Store `protobuf:"bytes,3,opt,name=negativeValues,proto3" json:"negativeValues,omitempty"`
	// The count for the value zero and its close neighborhood (whose width depends on the mapping).
	ZeroCount            float64  `protobuf:"fixed64,4,opt,name=zeroCount,proto3" json:"zeroCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DDSketch) Reset()         { *m = DDSketch{} }
func (m *DDSketch) String() string { return proto.CompactTextString(m) }
func (*DDSketch) ProtoMessage()    {}
func (*DDSketch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{0}
}

func (m *DDSketch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DDSketch.Unmarshal(m, b)
}
func (m *DDSketch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DDSketch.Marshal(b, m, deterministic)
}
func (m *DDSketch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDSketch.Merge(m, src)
}
func (m *DDSketch) XXX_Size() int {
	return xxx_messageInfo_DDSketch.Size(m)
}
func (m *DDSketch) XXX_DiscardUnknown() {
	xxx_messageInfo_DDSketch.DiscardUnknown(m)
}

var xxx_messageInfo_DDSketch proto.InternalMessageInfo

func (m *DDSketch) GetMapping() *IndexMapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *DDSketch) GetPositiveValues() *Store {
	if m != nil {
		return m.PositiveValues
	}
	return nil
}

func (m *DDSketch) GetNegativeValues() *Store {
	if m != nil {
		return m.NegativeValues
	}
	return nil
}

func (m *DDSketch) GetZeroCount() float64 {
	if m != nil {
		return m.ZeroCount
	}
	return 0
}

// How to map positive values to the bins they belong to.
type IndexMapping struct {
	// The gamma parameter of the mapping, such that bin index that a value v belongs to is roughly equal to
	// log(v)/log(gamma).
	Gamma float64 `protobuf:"fixed64,1,opt,name=gamma,proto3" json:"gamma,omitempty"`
	// An offset that can be used to shift all bin indexes.
	IndexOffset float64 `protobuf:"fixed64,2,opt,name=indexOffset,proto3" json:"indexOffset,omitempty"`
	// To speed up the computation of the index a value belongs to, the computation of the log may be approximated using
	// the fact that the log to the base 2 of powers of 2 can be computed at a low cost from the binary representation of
	// the input value. Other values can be approximated by interpolating between successive powers of 2 (linearly,
	// quadratically or cubically).
	// NONE means that the log is to be computed exactly (no interpolation).
	Interpolation        IndexMapping_Interpolation `protobuf:"varint,3,opt,name=interpolation,proto3,enum=IndexMapping_Interpolation" json:"interpolation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *IndexMapping) Reset()         { *m = IndexMapping{} }
func (m *IndexMapping) String() string { return proto.CompactTextString(m) }
func (*IndexMapping) ProtoMessage()    {}
func (*IndexMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{1}
}

func (m *IndexMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IndexMapping.Unmarshal(m, b)
}
func (m *IndexMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IndexMapping.Marshal(b, m, deterministic)
}
func (m *IndexMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexMapping.Merge(m, src)
}
func (m *IndexMapping) XXX_Size() int {
	return xxx_messageInfo_IndexMapping.Size(m)
}
func (m *IndexMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexMapping.DiscardUnknown(m)
}

var xxx_messageInfo_IndexMapping proto.InternalMessageInfo

func (m *IndexMapping) GetGamma() float64 {
	if m != nil {
		return m.Gamma
	}
	return 0
}

func (m *IndexMapping) GetIndexOffset() float64 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *IndexMapping) GetInterpolation() IndexMapping_Interpolation {
	if m != nil {
		return m.Interpolation
	}
	return IndexMapping_NONE
}

// A Store maps bin indexes to their respective counts.
// Counts can be encoded sparsely using binCounts, but also in a contiguous way using contiguousBinCounts and
// contiguousBinIndexOffset. Given that non-empty bins are in practice usually contiguous or close to one another, the
// latter contiguous encoding method is usually more efficient than the sparse one.
// Both encoding methods can be used conjointly. If a bin appears in both the sparse and the contiguous encodings, its
// count value is the sum of the counts in each encodings.
type Store struct {
	// The bin counts, encoded sparsely.
	BinCounts map[int32]float64 `protobuf:"bytes,1,rep,name=binCounts,proto3" json:"binCounts,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// The bin counts, encoded contiguously. The values of contiguousBinCounts are the counts for the bins of indexes
	// o, o+1, o+2, etc., where o is contiguousBinIndexOffset.
	ContiguousBinCounts      []float64 `protobuf:"fixed64,2,rep,packed,name=contiguousBinCounts,proto3" json:"contiguousBinCounts,omitempty"`
	ContiguousBinIndexOffset int32     `protobuf:"zigzag32,3,opt,name=contiguousBinIndexOffset,proto3" json:"contiguousBinIndexOffset,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}  `json:"-"`
	XXX_unrecognized         []byte    `json:"-"`
	XXX_sizecache            int32     `json:"-"`
}

func (m *Store) Reset()         { *m = Store{} }
func (m *Store) String() string { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()    {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc8a52eb53c27981, []int{2}
}

func (m *Store) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Store.Unmarshal(m, b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Store.Marshal(b, m, deterministic)
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return xxx_messageInfo_Store.Size(m)
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetBinCounts() map[int32]float64 {
	if m != nil {
		return m.BinCounts
	}
	return nil
}

func (m *Store) GetContiguousBinCounts() []float64 {
	if m != nil {
		return m.ContiguousBinCounts
	}
	return nil
}

func (m *Store) GetContiguousBinIndexOffset() int32 {
	if m != nil {
		return m.ContiguousBinIndexOffset
	}
	return 0
}

func init() {
	proto.RegisterEnum("IndexMapping_Interpolation", IndexMapping_Interpolation_name, IndexMapping_Interpolation_value)
	proto.RegisterType((*DDSketch)(nil), "DDSketch")
	proto.RegisterType((*IndexMapping)(nil), "IndexMapping")
	proto.RegisterType((*Store)(nil), "Store")
	proto.RegisterMapType((map[int32]float64)(nil), "Store.BinCountsEntry")
}

func init() {
	proto.RegisterFile("ddsketch.proto", fileDescriptor_bc8a52eb53c27981)
}

var fileDescriptor_bc8a52eb53c27981 = []byte{
	// 417 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0x19, 0xbb, 0x09, 0xcd, 0x0d, 0xb1, 0xdc, 0x01, 0x24, 0x0b, 0x58, 0x58, 0xde, 0xe0,
	0x0d, 0xb6, 0x94, 0x80, 0x84, 0x2a, 0x24, 0xe4, 0x9f, 0x2c, 0x2c, 0x41, 0x2a, 0xa6, 0x94, 0x05,
	0xbb, 0x71, 0x32, 0x75, 0x47, 0xad, 0x67, 0x2c, 0x7b, 0x5c, 0x51, 0xde, 0x8a, 0xd7, 0xe0, 0x59,
	0x78, 0x08, 0xe4, 0x71, 0x43, 0x6c, 0x04, 0x3b, 0xcf, 0x39, 0x9f, 0xa5, 0x73, 0xcf, 0xbd, 0x60,
	0xed, 0x76, 0xcd, 0x35, 0x53, 0xdb, 0xab, 0xa0, 0xaa, 0xa5, 0x92, 0xde, 0x0f, 0x04, 0xc7, 0x69,
	0x7a, 0xae, 0x25, 0xfc, 0x12, 0x1e, 0x96, 0xb4, 0xaa, 0xb8, 0x28, 0x1c, 0xe4, 0x22, 0x7f, 0xbe,
	0x5c, 0x04, 0x99, 0xd8, 0xb1, 0x6f, 0x1f, 0x7b, 0x91, 0xec, 0x5d, 0x1c, 0x80, 0x55, 0xc9, 0x86,
	0x2b, 0x7e, 0xcb, 0xbe, 0xd0, 0x9b, 0x96, 0x35, 0x8e, 0xa1, 0xf9, 0x69, 0x70, 0xae, 0x64, 0xcd,
	0xc8, 0x5f, 0x6e, 0xc7, 0x0b, 0x56, 0xd0, 0x01, 0x6f, 0x8e, 0xf9, 0xb1, 0x8b, 0x5f, 0xc0, 0xec,
	0x3b, 0xab, 0x65, 0x22, 0x5b, 0xa1, 0x9c, 0x23, 0x17, 0xf9, 0x88, 0x1c, 0x04, 0xef, 0x27, 0x82,
	0x47, 0xc3, 0x5c, 0xf8, 0x09, 0x4c, 0x0a, 0x5a, 0x96, 0x54, 0xa7, 0x46, 0xa4, 0x7f, 0x60, 0x17,
	0xe6, 0xbc, 0xa3, 0xce, 0x2e, 0x2f, 0x1b, 0xa6, 0x74, 0x42, 0x44, 0x86, 0x12, 0x8e, 0x60, 0xc1,
	0x85, 0x62, 0x75, 0x25, 0x6f, 0xa8, 0xe2, 0x52, 0xe8, 0x54, 0xd6, 0xf2, 0xf9, 0x68, 0xea, 0x20,
	0x1b, 0x22, 0x64, 0xfc, 0x87, 0xf7, 0x1e, 0x16, 0x23, 0x1f, 0x1f, 0xc3, 0xd1, 0xe6, 0x6c, 0xb3,
	0xb6, 0x1f, 0x60, 0x80, 0xe9, 0x87, 0x6c, 0xb3, 0x8e, 0x88, 0x8d, 0xf0, 0x02, 0x66, 0x9f, 0x2e,
	0xa2, 0x94, 0x44, 0x9f, 0xb3, 0xc4, 0x36, 0xf0, 0x0c, 0x26, 0xc9, 0x45, 0x9c, 0x25, 0xb6, 0xe9,
	0xfd, 0x42, 0x30, 0xd1, 0x25, 0xe0, 0x15, 0xcc, 0x72, 0x2e, 0xf4, 0x88, 0x8d, 0x83, 0x5c, 0xd3,
	0x9f, 0x2f, 0x9f, 0xf6, 0xfd, 0x04, 0xf1, 0x5e, 0x5f, 0x0b, 0x55, 0xdf, 0x91, 0x03, 0x87, 0x5f,
	0xc3, 0xe3, 0xad, 0x14, 0x8a, 0x17, 0xad, 0x6c, 0x9b, 0x3f, 0x98, 0x63, 0xb8, 0xa6, 0x8f, 0x62,
	0xc3, 0x46, 0xe4, 0x5f, 0x36, 0x3e, 0x05, 0x67, 0x24, 0x67, 0x83, 0x9e, 0xba, 0x0e, 0x4e, 0xc8,
	0x7f, 0xfd, 0x67, 0xef, 0xc0, 0x1a, 0xc7, 0xc1, 0x36, 0x98, 0xd7, 0xec, 0x4e, 0x97, 0x7f, 0x42,
	0xba, 0xcf, 0x6e, 0x21, 0xb7, 0xdd, 0x26, 0xef, 0x4b, 0xef, 0x1f, 0xa7, 0xc6, 0x5b, 0x14, 0xbf,
	0xf9, 0xba, 0x2a, 0xb8, 0xba, 0x6a, 0xf3, 0x60, 0x2b, 0xcb, 0x30, 0xa5, 0x8a, 0xa6, 0xb2, 0x08,
	0xfb, 0x93, 0x64, 0xcd, 0xab, 0x42, 0x86, 0xfb, 0x03, 0x0d, 0xab, 0xfc, 0x5e, 0xaf, 0xf2, 0x7c,
	0xaa, 0xaf, 0x75, 0xf5, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x72, 0xf3, 0x8e, 0x54, 0xbf, 0x02, 0x00,
	0x00,
}
