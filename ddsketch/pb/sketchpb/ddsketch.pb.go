// Code generated by protoc-gen-gogo.
// source: ddsketch.proto
// DO NOT EDIT!

/*
	Package sketchpb is a generated protocol buffer package.

	It is generated from these files:
		ddsketch.proto

	It has these top-level messages:
		DDSketch
		IndexMapping
		Store
*/
package sketchpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type IndexMapping_Interpolation int32

const (
	IndexMapping_NONE      IndexMapping_Interpolation = 0
	IndexMapping_LINEAR    IndexMapping_Interpolation = 1
	IndexMapping_QUADRATIC IndexMapping_Interpolation = 2
	IndexMapping_CUBIC     IndexMapping_Interpolation = 3
)

var IndexMapping_Interpolation_name = map[int32]string{
	0: "NONE",
	1: "LINEAR",
	2: "QUADRATIC",
	3: "CUBIC",
}
var IndexMapping_Interpolation_value = map[string]int32{
	"NONE":      0,
	"LINEAR":    1,
	"QUADRATIC": 2,
	"CUBIC":     3,
}

func (x IndexMapping_Interpolation) String() string {
	return proto.EnumName(IndexMapping_Interpolation_name, int32(x))
}
func (IndexMapping_Interpolation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorDdsketch, []int{1, 0}
}

// A DDSketch is essentially a histogram that partitions the range of positive values into an infinite number of
// indexed bins whose size grows exponentially. It keeps track of the number of values (or possibly floating-point
// weights) added to each bin. Negative values are partitioned like positive values, symmetrically to zero.
// The value zero as well as its close neighborhood that would be mapped to extreme bin indexes is mapped to a specific
// counter.
type DDSketch struct {
	// The mapping between positive values and the bin indexes they belong to.
	Mapping *IndexMapping `protobuf:"bytes,1,opt,name=mapping" json:"mapping,omitempty"`
	// The store for keeping track of positive values.
	PositiveValues *Store `protobuf:"bytes,2,opt,name=positiveValues" json:"positiveValues,omitempty"`
	// The store for keeping track of negative values. A negative value v is mapped using its positive opposite -v.
	NegativeValues *Store `protobuf:"bytes,3,opt,name=negativeValues" json:"negativeValues,omitempty"`
	// The count for the value zero and its close neighborhood (whose width depends on the mapping).
	ZeroCount float64 `protobuf:"fixed64,4,opt,name=zeroCount,proto3" json:"zeroCount,omitempty"`
}

func (m *DDSketch) Reset()                    { *m = DDSketch{} }
func (m *DDSketch) String() string            { return proto.CompactTextString(m) }
func (*DDSketch) ProtoMessage()               {}
func (*DDSketch) Descriptor() ([]byte, []int) { return fileDescriptorDdsketch, []int{0} }

func (m *DDSketch) GetMapping() *IndexMapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *DDSketch) GetPositiveValues() *Store {
	if m != nil {
		return m.PositiveValues
	}
	return nil
}

func (m *DDSketch) GetNegativeValues() *Store {
	if m != nil {
		return m.NegativeValues
	}
	return nil
}

// How to map positive values to the bins they belong to.
type IndexMapping struct {
	// The gamma parameter of the mapping, such that bin index that a value v belongs to is roughly equal to
	// log(v)/log(gamma).
	Gamma float64 `protobuf:"fixed64,1,opt,name=gamma,proto3" json:"gamma,omitempty"`
	// An offset that can be used to shift all bin indexes.
	IndexOffset float64 `protobuf:"fixed64,2,opt,name=indexOffset,proto3" json:"indexOffset,omitempty"`
	// To speed up the computation of the index a value belongs to, the computation of the log may be approximated using
	// the fact that the log to the base 2 of powers of 2 can be computed at a low cost from the binary representation of
	// the input value. Other values can be approximated by interpolating between successive powers of 2 (linearly,
	// quadratically or cubically).
	// NONE means that the log is to be computed exactly (no interpolation).
	Interpolation IndexMapping_Interpolation `protobuf:"varint,3,opt,name=interpolation,proto3,enum=IndexMapping_Interpolation" json:"interpolation,omitempty"`
}

func (m *IndexMapping) Reset()                    { *m = IndexMapping{} }
func (m *IndexMapping) String() string            { return proto.CompactTextString(m) }
func (*IndexMapping) ProtoMessage()               {}
func (*IndexMapping) Descriptor() ([]byte, []int) { return fileDescriptorDdsketch, []int{1} }

// A Store maps bin indexes to their respective counts.
// Counts can be encoded sparsely using binCounts, but also in a contiguous way using contiguousBinCounts and
// contiguousBinIndexOffset. Given that non-empty bins are in practice usually contiguous or close to one another, the
// latter contiguous encoding method is usually more efficient than the sparse one.
// Both encoding methods can be used conjointly. If a bin appears in both the sparse and the contiguous encodings, its
// count value is the sum of the counts in each encodings.
type Store struct {
	// The bin counts, encoded sparsely.
	BinCounts map[int32]float64 `protobuf:"bytes,1,rep,name=binCounts" json:"binCounts,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// The bin counts, encoded contiguously. The values of contiguousBinCounts are the counts for the bins of indexes
	// o, o+1, o+2, etc., where o is contiguousBinIndexOffset.
	ContiguousBinCounts      []float64 `protobuf:"fixed64,2,rep,packed,name=contiguousBinCounts" json:"contiguousBinCounts,omitempty"`
	ContiguousBinIndexOffset int32     `protobuf:"zigzag32,3,opt,name=contiguousBinIndexOffset,proto3" json:"contiguousBinIndexOffset,omitempty"`
}

func (m *Store) Reset()                    { *m = Store{} }
func (m *Store) String() string            { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()               {}
func (*Store) Descriptor() ([]byte, []int) { return fileDescriptorDdsketch, []int{2} }

func (m *Store) GetBinCounts() map[int32]float64 {
	if m != nil {
		return m.BinCounts
	}
	return nil
}

func init() {
	proto.RegisterType((*DDSketch)(nil), "DDSketch")
	proto.RegisterType((*IndexMapping)(nil), "IndexMapping")
	proto.RegisterType((*Store)(nil), "Store")
	proto.RegisterEnum("IndexMapping_Interpolation", IndexMapping_Interpolation_name, IndexMapping_Interpolation_value)
}
func (m *DDSketch) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DDSketch) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mapping != nil {
		data[i] = 0xa
		i++
		i = encodeVarintDdsketch(data, i, uint64(m.Mapping.Size()))
		n1, err := m.Mapping.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PositiveValues != nil {
		data[i] = 0x12
		i++
		i = encodeVarintDdsketch(data, i, uint64(m.PositiveValues.Size()))
		n2, err := m.PositiveValues.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.NegativeValues != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintDdsketch(data, i, uint64(m.NegativeValues.Size()))
		n3, err := m.NegativeValues.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ZeroCount != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Ddsketch(data, i, uint64(math.Float64bits(float64(m.ZeroCount))))
	}
	return i, nil
}

func (m *IndexMapping) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IndexMapping) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gamma != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Ddsketch(data, i, uint64(math.Float64bits(float64(m.Gamma))))
	}
	if m.IndexOffset != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Ddsketch(data, i, uint64(math.Float64bits(float64(m.IndexOffset))))
	}
	if m.Interpolation != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDdsketch(data, i, uint64(m.Interpolation))
	}
	return i, nil
}

func (m *Store) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Store) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BinCounts) > 0 {
		for k, _ := range m.BinCounts {
			data[i] = 0xa
			i++
			v := m.BinCounts[k]
			mapSize := 1 + sozDdsketch(uint64(k)) + 1 + 8
			i = encodeVarintDdsketch(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintDdsketch(data, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			data[i] = 0x11
			i++
			i = encodeFixed64Ddsketch(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	if len(m.ContiguousBinCounts) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintDdsketch(data, i, uint64(len(m.ContiguousBinCounts)*8))
		for _, num := range m.ContiguousBinCounts {
			f4 := math.Float64bits(float64(num))
			data[i] = uint8(f4)
			i++
			data[i] = uint8(f4 >> 8)
			i++
			data[i] = uint8(f4 >> 16)
			i++
			data[i] = uint8(f4 >> 24)
			i++
			data[i] = uint8(f4 >> 32)
			i++
			data[i] = uint8(f4 >> 40)
			i++
			data[i] = uint8(f4 >> 48)
			i++
			data[i] = uint8(f4 >> 56)
			i++
		}
	}
	if m.ContiguousBinIndexOffset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintDdsketch(data, i, uint64((uint32(m.ContiguousBinIndexOffset)<<1)^uint32((m.ContiguousBinIndexOffset>>31))))
	}
	return i, nil
}

func encodeFixed64Ddsketch(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ddsketch(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDdsketch(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *DDSketch) Size() (n int) {
	var l int
	_ = l
	if m.Mapping != nil {
		l = m.Mapping.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.PositiveValues != nil {
		l = m.PositiveValues.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.NegativeValues != nil {
		l = m.NegativeValues.Size()
		n += 1 + l + sovDdsketch(uint64(l))
	}
	if m.ZeroCount != 0 {
		n += 9
	}
	return n
}

func (m *IndexMapping) Size() (n int) {
	var l int
	_ = l
	if m.Gamma != 0 {
		n += 9
	}
	if m.IndexOffset != 0 {
		n += 9
	}
	if m.Interpolation != 0 {
		n += 1 + sovDdsketch(uint64(m.Interpolation))
	}
	return n
}

func (m *Store) Size() (n int) {
	var l int
	_ = l
	if len(m.BinCounts) > 0 {
		for k, v := range m.BinCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sozDdsketch(uint64(k)) + 1 + 8
			n += mapEntrySize + 1 + sovDdsketch(uint64(mapEntrySize))
		}
	}
	if len(m.ContiguousBinCounts) > 0 {
		n += 1 + sovDdsketch(uint64(len(m.ContiguousBinCounts)*8)) + len(m.ContiguousBinCounts)*8
	}
	if m.ContiguousBinIndexOffset != 0 {
		n += 1 + sozDdsketch(uint64(m.ContiguousBinIndexOffset))
	}
	return n
}

func sovDdsketch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDdsketch(x uint64) (n int) {
	return sovDdsketch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DDSketch) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDSketch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDSketch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mapping == nil {
				m.Mapping = &IndexMapping{}
			}
			if err := m.Mapping.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositiveValues == nil {
				m.PositiveValues = &Store{}
			}
			if err := m.PositiveValues.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NegativeValues == nil {
				m.NegativeValues = &Store{}
			}
			if err := m.NegativeValues.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.ZeroCount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexMapping) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamma", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Gamma = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexOffset", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.IndexOffset = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interpolation", wireType)
			}
			m.Interpolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Interpolation |= (IndexMapping_Interpolation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdsketch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
			mapkey := int32(mapkeytemp)
			if m.BinCounts == nil {
				m.BinCounts = make(map[int32]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdsketch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.BinCounts[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.BinCounts[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdsketch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDdsketch
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.ContiguousBinCounts = append(m.ContiguousBinCounts, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.ContiguousBinCounts = append(m.ContiguousBinCounts, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ContiguousBinCounts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContiguousBinIndexOffset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ContiguousBinIndexOffset = v
		default:
			iNdEx = preIndex
			skippy, err := skipDdsketch(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdsketch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDdsketch(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDdsketch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdsketch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDdsketch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDdsketch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDdsketch(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDdsketch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDdsketch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ddsketch.proto", fileDescriptorDdsketch) }

var fileDescriptorDdsketch = []byte{
	// 439 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x41, 0x6e, 0xd3, 0x40,
	0x14, 0x86, 0xfb, 0xec, 0x26, 0x34, 0x2f, 0x24, 0x72, 0x07, 0x90, 0x2c, 0x40, 0x91, 0x95, 0x0d,
	0xd9, 0xe0, 0x48, 0x09, 0x0b, 0x54, 0x21, 0xa1, 0x24, 0xce, 0xc2, 0x12, 0xa4, 0x62, 0x4a, 0x59,
	0xb0, 0x1b, 0x27, 0x53, 0x77, 0xd4, 0x7a, 0xc6, 0xb2, 0xc7, 0x15, 0xe5, 0x14, 0x5c, 0x85, 0x5b,
	0x20, 0x56, 0x1c, 0x01, 0x85, 0x2d, 0x87, 0x40, 0x1e, 0x37, 0xd4, 0x46, 0x74, 0xe7, 0xf9, 0xff,
	0xcf, 0xd2, 0xff, 0xfe, 0xf7, 0xb0, 0xbf, 0xd9, 0xe4, 0x17, 0x5c, 0xaf, 0xcf, 0xfd, 0x34, 0x53,
	0x5a, 0x0d, 0xbf, 0x02, 0x1e, 0x04, 0xc1, 0x89, 0x91, 0xc8, 0x33, 0xbc, 0x97, 0xb0, 0x34, 0x15,
	0x32, 0x76, 0xc1, 0x83, 0x51, 0x77, 0xd2, 0xf3, 0x43, 0xb9, 0xe1, 0x9f, 0xde, 0x56, 0x22, 0xdd,
	0xb9, 0xc4, 0xc7, 0x7e, 0xaa, 0x72, 0xa1, 0xc5, 0x15, 0xff, 0xc0, 0x2e, 0x0b, 0x9e, 0xbb, 0x96,
	0xe1, 0xdb, 0xfe, 0x89, 0x56, 0x19, 0xa7, 0xff, 0xb8, 0x25, 0x2f, 0x79, 0xcc, 0x6a, 0xbc, 0xdd,
	0xe4, 0x9b, 0x2e, 0x79, 0x8a, 0x9d, 0xcf, 0x3c, 0x53, 0x0b, 0x55, 0x48, 0xed, 0xee, 0x7b, 0x30,
	0x02, 0x7a, 0x2b, 0x0c, 0xbf, 0x03, 0xde, 0xaf, 0xe7, 0x22, 0x0f, 0xb1, 0x15, 0xb3, 0x24, 0x61,
	0x26, 0x35, 0xd0, 0xea, 0x41, 0x3c, 0xec, 0x8a, 0x92, 0x3a, 0x3e, 0x3b, 0xcb, 0xb9, 0x36, 0x09,
	0x81, 0xd6, 0x25, 0x32, 0xc3, 0x9e, 0x90, 0x9a, 0x67, 0xa9, 0xba, 0x64, 0x5a, 0x28, 0x69, 0x52,
	0xf5, 0x27, 0x4f, 0x1a, 0x53, 0xfb, 0x61, 0x1d, 0xa1, 0xcd, 0x3f, 0x86, 0xaf, 0xb1, 0xd7, 0xf0,
	0xc9, 0x01, 0xee, 0xaf, 0x8e, 0x57, 0x4b, 0x67, 0x8f, 0x20, 0xb6, 0xdf, 0x84, 0xab, 0xe5, 0x8c,
	0x3a, 0x40, 0x7a, 0xd8, 0x79, 0x77, 0x3a, 0x0b, 0xe8, 0xec, 0x7d, 0xb8, 0x70, 0x2c, 0xd2, 0xc1,
	0xd6, 0xe2, 0x74, 0x1e, 0x2e, 0x1c, 0x7b, 0xf8, 0x1b, 0xb0, 0x65, 0x4a, 0x20, 0x53, 0xec, 0x44,
	0x42, 0x9a, 0x11, 0x73, 0x17, 0x3c, 0x7b, 0xd4, 0x9d, 0x3c, 0xaa, 0xfa, 0xf1, 0xe7, 0x3b, 0x7d,
	0x29, 0x75, 0x76, 0x4d, 0x6f, 0x39, 0xf2, 0x02, 0x1f, 0xac, 0x95, 0xd4, 0x22, 0x2e, 0x54, 0x91,
	0xff, 0xc5, 0x5c, 0xcb, 0xb3, 0x47, 0x30, 0xb7, 0x1c, 0xa0, 0xff, 0xb3, 0xc9, 0x11, 0xba, 0x0d,
	0x39, 0xac, 0xf5, 0x54, 0x76, 0x70, 0x48, 0xef, 0xf4, 0x1f, 0xbf, 0xc2, 0x7e, 0x33, 0x0e, 0x71,
	0xd0, 0xbe, 0xe0, 0xd7, 0xa6, 0xfc, 0x43, 0x5a, 0x7e, 0x96, 0x0b, 0xb9, 0x2a, 0x37, 0x79, 0x53,
	0x7a, 0xf5, 0x38, 0xb2, 0x5e, 0xc2, 0x7c, 0xf9, 0x6d, 0x3b, 0x80, 0x1f, 0xdb, 0x01, 0xfc, 0xdc,
	0x0e, 0xe0, 0xcb, 0xaf, 0xc1, 0xde, 0xc7, 0x69, 0x2c, 0xf4, 0x79, 0x11, 0xf9, 0x6b, 0x95, 0x8c,
	0x03, 0xa6, 0x59, 0xa0, 0xe2, 0x71, 0x75, 0xa2, 0x3c, 0x7f, 0x1e, 0xab, 0xf1, 0xee, 0x60, 0xc7,
	0x69, 0x74, 0xa3, 0xa7, 0x51, 0xd4, 0x36, 0xd7, 0x3b, 0xfd, 0x13, 0x00, 0x00, 0xff, 0xff, 0x9e,
	0x18, 0xa9, 0xe6, 0xcf, 0x02, 0x00, 0x00,
}
